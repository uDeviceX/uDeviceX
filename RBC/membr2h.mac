
/*

[1] Fedosov, Dmitry A. Multiscale modeling of blood flow and soft
matter. Brown University, 2010, PhD dissertation

[2] Dao, M., J. Li, and S. Suresh. "Molecularly based analysis of
deformation of spectrin network and human erythrocyte." Materials
Science and Engineering: C 26.8 (2006): 1232-1244.

[3] Mueller, K. In silico particle margination in blood
flow. Universitaet zu Koeln, 2015, PhD dissertation

*/

load ("scifac") $
load("abs_integrate");
load("scifac");
load("multiadditive") $
load("membr_utils.mac") $
load("shape_utils.mac") $

un('Velocity     , 'length/'time           , "velocity units") $
un('Energy       , 'mass*di('Velocity)^2   , "energy units") $
un('p1_v, 'length,    "radius vector of point 1");
un('Vb   , di(Energy), "bending energy");
un('Vsp  , di(Energy), "spring  energy");
un('Va   , di(Energy), "area    energy");
un('kbT  , di(Energy), "thermal    energy");
/* un('lm   , 'length   , "maximal spring extension"); */

declare(membrane_constant,                                    feature);
  
declare([kbT, ka , kb, A0, Arest              ],                membrane_constant) $
declare([l0,  ksp                             ],                membrane_constant) $

declare([p1_v, p2_v, p3_v],                                   nonscalar) $
declare([a12_v, a32_v],                                       nonscalar) $

adef: ['a12_v      = ('p1_v - 'p2_v),
       'a32_v      = ('p3_v - 'p2_v),
       'lj2        =  dot('a12_v, 'a12_v),
       'lj         =  sqrt(lj2),
       'A          =  1/2*cp('p2_v, 'p1_v),
       'ctheta      =  dot('a32_v,'a12_v)/sqrt( dot('a12_v,'a12_v)) / sqrt(dot('a32_v,'a32_v))
       ];

rdef: ['Vb         =  'kb*(1+'ctheta),
       'Acurrent   =  'A + 'Arest,
       'Va         =  'ka*('Acurrent - 'A0)^2/2 + 'kl*'Acurrent^2/2 ,
       'Vsp        =  'ksp*'(lj - l0)^2/2
];
%cvars%: ['p1_v, 'p2_v, 'p3_v];

ee: append(adef, rdef);

di_eq: mdi(ee);
di_eq: append(%mdi_extra_eq%, copylist(di_eq));
dvars: unique(map('first, args_of(di_eq, 'di)));
dvars: map(lambda([e], funmake('di, [e])), dvars);
dvars: map('log, dvars);
mso: block([logexpand: all, so],
  so: linsolve(log(di_eq), dvars),
  map(lambda([e], map('exp, e)), so));

mso: create_list( [first(lhs(v)), rhs(v), 'di], v, mso);
for m in mso do apply('qput, m);

eq: mdiff(ee);

cp_and_dot_vars(e):= block([A, B],
  A: listofvars(args_of(args_of( e,  'cp ), 'del)),
  B: listofvars(args_of(args_of( e,  'dot), 'del)),
  ldifference(append(A, B), %cvars%));
cp_and_dot_vars_emptyp(e):= emptyp(cp_and_dot_vars(e));

lvars: ldifference( listofvars(args_of(eq, del)), %cvars%);
lvars: map('del, lvars);

good: [];
bad : linsolve(eq, lvars);
while not emptyp(bad) do  (
  [good, bad] : pred_partition(append(good, bad), cp_and_dot_vars_emptyp),
  bad: subst(good, bad));

/* list of energies */
evars: ['Vb, 'Va, 'Vsp];

for v in %cvars% do (
  for e in evars do (
    d: assoc( del(e), good),
    d: resimp(d),
    Force[e, v]: gcfac(fullratsimp( -sdiff(d, del(v))))));

/* push a list `e' into list 'l' */
lpush(e):= (for a in e do push(a, body), body);

eq2as(e):= subst(":", "=", e);
eq2decl(e):= map('lhs, e);

cp (v, u):= dot(sk(v), u);
sk (v):=[-second(v), first(v)];
dot(v, u):= if u=0 or v=0 then 0
            else if listp(v) and listp(u) then xreduce("+", map("*", v, u)) else 'unknow;

list2block(d, b):= block([B: funmake("(", args(b))],
  funmake('block, [d, B]));

gen_fun(e, vars):= block([fname, body: [], decl: []],
  decl :  eq2decl(adef),
  fname:  concat('f, e),
  (body: [],
    lpush(eq2as(adef)),
    push(create_list(float(Force[e, v]), v, vars), body),
    body: reverse(body)),
  define(funmake(fname, vars), list2block(decl, body)),
  apply(fundef, [fname]));
gen_fun('Vb,  ['p1_v, 'p2_v, 'p3_v]);
gen_fun('Va,  ['p1_v, 'p2_v]);
gen_fun('Vsp, ['p1_v, 'p2_v]);

define(wrap(i), buildq([natoms],
      if i>natoms then i - natoms
      else if i<1 then i + natoms
      else i));

define(getA(), buildq([natoms], block([p1_v, p2_v, id1, id2, A],
      A: 0,
      for i: 1 thru natoms do (
        id1: i,
        id2: wrap(i+1),

        p1_v: R[id1],
        p2_v: R[id2],

        A: A + 1/2*cp(p2_v, p1_v)),
      A)));

define(getL(), buildq([natoms], block([p1_v, p2_v, a12_v, id1, id2, LL, listarith: true],
      LL: 0,
      for i: 1 thru natoms do (
        id1: i,
        id2: wrap(i+1),
        p1_v: R[id1],
        p2_v: R[id2],
        a12_v : p1_v - p2_v,
        LL: LL + sqrt(dot(a12_v, a12_v))),
      LL)));

define(getVsp(), buildq([natoms, Expr: assoc(Vsp, rdef),
    dec:  eq2decl(adef),
    def:    eq2as(adef)],
    block([E, id1, id2, p1_v, p2_v],
      E : 0,
      for i: 1 thru natoms do (
        id1: i,
        id2: wrap(i+1),

        p1_v: R[id1],
        p2_v: R[id2],
        block([splice(dec)],
          splice(def),
          E: E + Expr)),
      E)));

define(getVb(), buildq([natoms, Expr: assoc(Vb, rdef),
    dec: eq2decl(adef),
    def:    eq2as(adef)],
    block([E, id1, id2, id3, p1_v, p2_v, p3_v],
      E : 0,
      for i: 1 thru natoms do (
        id1: i,
        id2: wrap(i+1),
        id3: wrap(i+2),        

        p1_v: R[id1],
        p2_v: R[id2],
        p3_v: R[id3],
        
        block([splice(dec)],
          splice(def),
          E: E + Expr)),
      E)));

define(getKin(), buildq([natoms],
    block([E, v0],
      E: 0,
      for i: 1 thru natoms do (v0: v[i],
        E: E + dot(V[i], V[i])/2),
      E)));

define(getVa(), assoc(Va, rdef));

nullF():= (F: R0*0, 'done);
nullV():= (V: R0*0, 'done);

define(update_f_bond(), buildq([natoms], block([id1, id2, p1_v, p2_v],
    for i: 1 thru natoms do (
      id1: i,
      id2: wrap(i+1),

      p1_v: R[id1],
      p2_v: R[id2],

      [F[id1], F[id2]]: [F[id1], F[id2]] + fVsp(p1_v, p2_v) + fVa(p1_v, p2_v)))));

define(update_f_angle(), buildq([natoms], block([id1, id2, id3, p1_v, p2_v, p3_v],
    for i: 1 thru natoms do (
      id1:      i   ,
      id2: wrap(i+1),
      id3: wrap(i+2),      

      p1_v: R[id1],
      p2_v: R[id2],
      p3_v: R[id3],      
      [F[id1], F[id2], F[id3]]:  [F[id1], F[id2], F[id3]] + fVb(p1_v, p2_v, p3_v)))));

define(update_v(), buildq([natoms],
    for i: 1 thru natoms do V[i]: float(V[i] + dt*F[i])));

define(update_r(), buildq([natoms],
    for i: 1 thru natoms do R[i]: R[i] + dt*V[i]));

natoms: 50$
R0 : rest(gen_rbc(natoms), -1)$
R: copylist(R0)               $

R12: R[quotient(natoms, 4)+1] - R[quotient(natoms, 4)] $
l0 : sqrt(dot(R12, R12))       ;
A0 : getA()                    ;
L0 : getL()                    ;
D0 : 7.82                      ;

ka : 1e4                       ;
kb : 1e4                       ;
ksp: 1e3                       ;
kl : -5e3                       ;

dt : 5e-4;

load("maxima2lines.mac") $
R : rest(gen_sphere(natoms), -1)$
for i thru length(R) do R[i][1] : R[i][1] * 1.1;

block([numer: true],
  nullV(),
  Acurrent : getA(),
  En0 : float(getVa() + getVb() + getVsp() + getKin()),
  for itime: 0 thru 100000000 do (
    fname: printf(false, "membr.~9,'0d.lines", itime),
    Acurrent : getA(),
    Lcurrent : getL(),
    if mod(itime, 100)=0 then (
      maxima2lines(fname, cons(last(R), R)),
      En : float(getVa() + getVb() + getVsp() + getKin()),
      print(['tot, En-En0, getKin(), Acurrent/A0, Lcurrent/L0])),
    
    nullF(),
    update_f_bond(),
    update_f_angle(),
    nullV(),
    update_v(),
    update_r()));
